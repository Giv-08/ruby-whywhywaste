function t(c){return c.split("-")[0]}function e(c){return c.split("-")[1]}function n(c){return["top","bottom"].includes(t(c))?"x":"y"}function r(c){return"y"===c?"height":"width"}function i(c,f,g){let{reference:h,floating:x}=c;const w=h.x+h.width/2-x.width/2,C=h.y+h.height/2-x.height/2,H=n(f),B=r(H),V=h[B]/2-x[B]/2,z="x"===H;let F;switch(t(f)){case"top":F={x:w,y:h.y-x.height};break;case"bottom":F={x:w,y:h.y+h.height};break;case"right":F={x:h.x+h.width,y:C};break;case"left":F={x:h.x-x.width,y:C};break;default:F={x:h.x,y:h.y}}switch(e(f)){case"start":F[H]-=V*(g&&z?-1:1);break;case"end":F[H]+=V*(g&&z?-1:1)}return F}const o=async(c,f,g)=>{const{placement:h="bottom",strategy:x="absolute",middleware:w=[],platform:C}=g,H=await(null==C.isRTL?void 0:C.isRTL(f));let B=await C.getElementRects({reference:c,floating:f,strategy:x}),{x:V,y:z}=i(B,h,H),F=h,M={},S=0;for(let g=0;g<w.length;g++){const{name:W,fn:j}=w[g],{x:q,y:G,data:I,reset:J}=await j({x:V,y:z,initialPlacement:h,placement:F,strategy:x,middlewareData:M,rects:B,platform:C,elements:{reference:c,floating:f}});V=null!=q?q:V,z=null!=G?G:z,M={...M,[W]:{...M[W],...I}},J&&S<=50&&(S++,"object"==typeof J&&(J.placement&&(F=J.placement),J.rects&&(B=!0===J.rects?await C.getElementRects({reference:c,floating:f,strategy:x}):J.rects),({x:V,y:z}=i(B,F,H))),g=-1)}return{x:V,y:z,placement:F,strategy:x,middlewareData:M}};function a(c){return"number"!=typeof c?function(c){return{top:0,right:0,bottom:0,left:0,...c}}(c):{top:c,right:c,bottom:c,left:c}}function l(c){return{...c,top:c.y,left:c.x,right:c.x+c.width,bottom:c.y+c.height}}async function s(c,f){var g;void 0===f&&(f={});const{x:h,y:x,platform:w,rects:C,elements:H,strategy:B}=c,{boundary:V="clippingAncestors",rootBoundary:z="viewport",elementContext:F="floating",altBoundary:M=!1,padding:S=0}=f,W=a(S),j=H[M?"floating"===F?"reference":"floating":F],q=l(await w.getClippingRect({element:null==(g=await(null==w.isElement?void 0:w.isElement(j)))||g?j:j.contextElement||await(null==w.getDocumentElement?void 0:w.getDocumentElement(H.floating)),boundary:V,rootBoundary:z,strategy:B})),G=l(w.convertOffsetParentRelativeRectToViewportRelativeRect?await w.convertOffsetParentRelativeRectToViewportRelativeRect({rect:"floating"===F?{...C.floating,x:h,y:x}:C.reference,offsetParent:await(null==w.getOffsetParent?void 0:w.getOffsetParent(H.floating)),strategy:B}):C[F]);return{top:q.top-G.top+W.top,bottom:G.bottom-q.bottom+W.bottom,left:q.left-G.left+W.left,right:G.right-q.right+W.right}}const c=Math.min,f=Math.max;function u(g,h,x){return f(g,c(h,x))}const m=c=>({name:"arrow",options:c,async fn(f){const{element:g,padding:h=0}=null!=c?c:{},{x:x,y:w,placement:C,rects:H,platform:B}=f;if(null==g)return{};const V=a(h),z={x:x,y:w},F=n(C),M=e(C),S=r(F),W=await B.getDimensions(g),j="y"===F?"top":"left",q="y"===F?"bottom":"right",G=H.reference[S]+H.reference[F]-z[F]-H.floating[S],I=z[F]-H.reference[F],J=await(null==B.getOffsetParent?void 0:B.getOffsetParent(g));let K=J?"y"===F?J.clientHeight||0:J.clientWidth||0:0;0===K&&(K=H.floating[S]);const N=G/2-I/2,Q=V[j],U=K-W[S]-V[q],X=K/2-W[S]/2+N,Y=u(Q,X,U),Z=("start"===M?V[j]:V[q])>0&&X!==Y&&H.reference[S]<=H.floating[S];return{[F]:z[F]-(Z?X<Q?Q-X:U-X:0),data:{[F]:Y,centerOffset:X-Y}}}}),g={left:"right",right:"left",bottom:"top",top:"bottom"};function d(c){return c.replace(/left|right|bottom|top/g,(c=>g[c]))}function p(c,f,g){void 0===g&&(g=!1);const h=e(c),x=n(c),w=r(x);let C="x"===x?h===(g?"end":"start")?"right":"left":"start"===h?"bottom":"top";return f.reference[w]>f.floating[w]&&(C=d(C)),{main:C,cross:d(C)}}const h={start:"end",end:"start"};function y(c){return c.replace(/start|end/g,(c=>h[c]))}const x=["top","right","bottom","left"],w=x.reduce(((c,f)=>c.concat(f,f+"-start",f+"-end")),[]);const v=function(c){return void 0===c&&(c={}),{name:"autoPlacement",options:c,async fn(f){var g,h,x,C,H;const{x:B,y:V,rects:z,middlewareData:F,placement:M,platform:S,elements:W}=f,{alignment:j=null,allowedPlacements:q=w,autoAlignment:G=!0,...I}=c,J=function(c,f,g){return(c?[...g.filter((f=>e(f)===c)),...g.filter((f=>e(f)!==c))]:g.filter((c=>t(c)===c))).filter((g=>!c||e(g)===c||!!f&&y(g)!==g))}(j,G,q),K=await s(f,I),N=null!=(g=null==(h=F.autoPlacement)?void 0:h.index)?g:0,Q=J[N];if(null==Q)return{};const{main:U,cross:X}=p(Q,z,await(null==S.isRTL?void 0:S.isRTL(W.floating)));if(M!==Q)return{x:B,y:V,reset:{placement:J[0]}};const Y=[K[t(Q)],K[U],K[X]],Z=[...null!=(x=null==(C=F.autoPlacement)?void 0:C.overflows)?x:[],{placement:Q,overflows:Y}],$=J[N+1];if($)return{data:{index:N+1,overflows:Z},reset:{placement:$}};const _=Z.slice().sort(((c,f)=>c.overflows[0]-f.overflows[0])),tt=null==(H=_.find((c=>{let{overflows:f}=c;return f.every((c=>c<=0))})))?void 0:H.placement,et=null!=tt?tt:_[0].placement;return et!==M?{data:{index:N+1,overflows:Z},reset:{placement:et}}:{}}}};const b=function(c){return void 0===c&&(c={}),{name:"flip",options:c,async fn(f){var g;const{placement:h,middlewareData:x,rects:w,initialPlacement:C,platform:H,elements:B}=f,{mainAxis:V=!0,crossAxis:z=!0,fallbackPlacements:F,fallbackStrategy:M="bestFit",flipAlignment:S=!0,...W}=c,j=t(h),q=F||(j!==C&&S?function(c){const f=d(c);return[y(c),f,y(f)]}(C):[d(C)]),G=[C,...q],I=await s(f,W),J=[];let K=(null==(g=x.flip)?void 0:g.overflows)||[];if(V&&J.push(I[j]),z){const{main:c,cross:f}=p(h,w,await(null==H.isRTL?void 0:H.isRTL(B.floating)));J.push(I[c],I[f])}if(K=[...K,{placement:h,overflows:J}],!J.every((c=>c<=0))){var N,Q;const c=(null!=(N=null==(Q=x.flip)?void 0:Q.index)?N:0)+1,f=G[c];if(f)return{data:{index:c,overflows:K},reset:{placement:f}};let g="bottom";switch(M){case"bestFit":{var U;const c=null==(U=K.map((c=>[c,c.overflows.filter((c=>c>0)).reduce(((c,f)=>c+f),0)])).sort(((c,f)=>c[1]-f[1]))[0])?void 0:U[0].placement;c&&(g=c);break}case"initialPlacement":g=C}if(h!==g)return{reset:{placement:g}}}return{}}}};function R(c,f){return{top:c.top-f.height,right:c.right-f.width,bottom:c.bottom-f.height,left:c.left-f.width}}function A(c){return x.some((f=>c[f]>=0))}const P=function(c){let{strategy:f="referenceHidden",...g}=void 0===c?{}:c;return{name:"hide",async fn(c){const{rects:h}=c;switch(f){case"referenceHidden":{const f=R(await s(c,{...g,elementContext:"reference"}),h.reference);return{data:{referenceHiddenOffsets:f,referenceHidden:A(f)}}}case"escaped":{const f=R(await s(c,{...g,altBoundary:!0}),h.floating);return{data:{escapedOffsets:f,escaped:A(f)}}}default:return{}}}}};const T=function(c){return void 0===c&&(c=0),{name:"offset",options:c,async fn(f){const{x:g,y:h}=f,x=await async function(c,f){const{placement:g,platform:h,elements:x}=c,w=await(null==h.isRTL?void 0:h.isRTL(x.floating)),C=t(g),H=e(g),B="x"===n(g),V=["left","top"].includes(C)?-1:1,z=w&&B?-1:1,F="function"==typeof f?f(c):f;let{mainAxis:M,crossAxis:S,alignmentAxis:W}="number"==typeof F?{mainAxis:F,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...F};return H&&"number"==typeof W&&(S="end"===H?-1*W:W),B?{x:S*z,y:M*V}:{x:M*V,y:S*z}}(f,c);return{x:g+x.x,y:h+x.y,data:x}}}};function O(c){return"x"===c?"y":"x"}const D=function(c){return void 0===c&&(c={}),{name:"shift",options:c,async fn(f){const{x:g,y:h,placement:x}=f,{mainAxis:w=!0,crossAxis:C=!1,limiter:H={fn:c=>{let{x:f,y:g}=c;return{x:f,y:g}}},...B}=c,V={x:g,y:h},z=await s(f,B),F=n(t(x)),M=O(F);let S=V[F],W=V[M];if(w){const c="y"===F?"bottom":"right";S=u(S+z["y"===F?"top":"left"],S,S-z[c])}if(C){const c="y"===M?"bottom":"right";W=u(W+z["y"===M?"top":"left"],W,W-z[c])}const j=H.fn({...f,[F]:S,[M]:W});return{...j,data:{x:j.x-g,y:j.y-h}}}}},L=function(c){return void 0===c&&(c={}),{options:c,fn(f){const{x:g,y:h,placement:x,rects:w,middlewareData:C}=f,{offset:H=0,mainAxis:B=!0,crossAxis:V=!0}=c,z={x:g,y:h},F=n(x),M=O(F);let S=z[F],W=z[M];const j="function"==typeof H?H({...w,placement:x}):H,q="number"==typeof j?{mainAxis:j,crossAxis:0}:{mainAxis:0,crossAxis:0,...j};if(B){const c="y"===F?"height":"width",f=w.reference[F]-w.floating[c]+q.mainAxis,g=w.reference[F]+w.reference[c]-q.mainAxis;S<f?S=f:S>g&&(S=g)}if(V){var G,I,J,K;const c="y"===F?"width":"height",f=["top","left"].includes(t(x)),g=w.reference[M]-w.floating[c]+(f&&null!=(G=null==(I=C.offset)?void 0:I[M])?G:0)+(f?0:q.crossAxis),h=w.reference[M]+w.reference[c]+(f?0:null!=(J=null==(K=C.offset)?void 0:K[M])?J:0)-(f?q.crossAxis:0);W<g?W=g:W>h&&(W=h)}return{[F]:S,[M]:W}}}},k=function(c){return void 0===c&&(c={}),{name:"size",options:c,async fn(g){const{placement:h,rects:x,platform:w,elements:C}=g,{apply:H,...B}=c,V=await s(g,B),z=t(h),F=e(h);let M,S;"top"===z||"bottom"===z?(M=z,S=F===(await(null==w.isRTL?void 0:w.isRTL(C.floating))?"start":"end")?"left":"right"):(S=z,M="end"===F?"top":"bottom");const W=f(V.left,0),j=f(V.right,0),q=f(V.top,0),G=f(V.bottom,0),I={availableHeight:x.floating.height-(["left","right"].includes(h)?2*(0!==q||0!==G?q+G:f(V.top,V.bottom)):V[M]),availableWidth:x.floating.width-(["top","bottom"].includes(h)?2*(0!==W||0!==j?W+j:f(V.left,V.right)):V[S])},J=await w.getDimensions(C.floating);null==H||H({...g,...I});const K=await w.getDimensions(C.floating);return J.width!==K.width||J.height!==K.height?{reset:{rects:!0}}:{}}}},E=function(g){return void 0===g&&(g={}),{name:"inline",options:g,async fn(h){var x;const{placement:w,elements:C,rects:H,platform:B,strategy:V}=h,{padding:z=2,x:F,y:M}=g,S=l(B.convertOffsetParentRelativeRectToViewportRelativeRect?await B.convertOffsetParentRelativeRectToViewportRelativeRect({rect:H.reference,offsetParent:await(null==B.getOffsetParent?void 0:B.getOffsetParent(C.floating)),strategy:V}):H.reference),W=null!=(x=await(null==B.getClientRects?void 0:B.getClientRects(C.reference)))?x:[],j=a(z);const q=await B.getElementRects({reference:{getBoundingClientRect:function(){var g;if(2===W.length&&W[0].left>W[1].right&&null!=F&&null!=M)return null!=(g=W.find((c=>F>c.left-j.left&&F<c.right+j.right&&M>c.top-j.top&&M<c.bottom+j.bottom)))?g:S;if(W.length>=2){if("x"===n(w)){const c=W[0],f=W[W.length-1],g="top"===t(w),h=c.top,x=f.bottom,C=g?c.left:f.left,H=g?c.right:f.right;return{top:h,bottom:x,left:C,right:H,width:H-C,height:x-h,x:C,y:h}}const g="left"===t(w),h=f(...W.map((c=>c.right))),x=c(...W.map((c=>c.left))),C=W.filter((c=>g?c.left===x:c.right===h)),H=C[0].top,B=C[C.length-1].bottom;return{top:H,bottom:B,left:x,right:h,width:h-x,height:B-H,x:x,y:H}}return S}},floating:C.floating,strategy:V});return H.reference.x!==q.reference.x||H.reference.y!==q.reference.y||H.reference.width!==q.reference.width||H.reference.height!==q.reference.height?{reset:{rects:q}}:{}}}};export{m as arrow,v as autoPlacement,o as computePosition,s as detectOverflow,b as flip,P as hide,E as inline,L as limitShift,T as offset,l as rectToClientRect,D as shift,k as size};

