import{tabbable as e,focusable as t,isTabbable as a,isFocusable as n}from"tabbable";
/*!
* focus-trap 6.9.4
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/function ownKeys(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function _objectSpread2(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?ownKeys(Object(a),!0).forEach((function(t){_defineProperty(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):ownKeys(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function _defineProperty(e,t,a){t in e?Object.defineProperty(e,t,{value:a,enumerable:true,configurable:true,writable:true}):e[t]=a;return e}var r=function(){var e=[];return{activateTrap:function activateTrap(t){if(e.length>0){var a=e[e.length-1];a!==t&&a.pause()}var n=e.indexOf(t);if(-1===n)e.push(t);else{e.splice(n,1);e.push(t)}},deactivateTrap:function deactivateTrap(t){var a=e.indexOf(t);-1!==a&&e.splice(a,1);e.length>0&&e[e.length-1].unpause()}}}();var o=function isSelectableInput(e){return e.tagName&&"input"===e.tagName.toLowerCase()&&"function"===typeof e.select};var i=function isEscapeEvent(e){return"Escape"===e.key||"Esc"===e.key||27===e.keyCode};var u=function isTabEvent(e){return"Tab"===e.key||9===e.keyCode};var c=function delay(e){return setTimeout(e,0)};var s=function findIndex(e,t){var a=-1;e.every((function(e,n){if(t(e)){a=n;return false}return true}));return a};
/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */var l=function valueOrHandler(e){for(var t=arguments.length,a=new Array(t>1?t-1:0),n=1;n<t;n++)a[n-1]=arguments[n];return"function"===typeof e?e.apply(void 0,a):e};var v=function getActualTarget(e){return e.target.shadowRoot&&"function"===typeof e.composedPath?e.composedPath()[0]:e.target};var f=function createFocusTrap(f,b){var d=(null===b||void 0===b?void 0:b.document)||document;var p=_objectSpread2({returnFocusOnDeactivate:true,escapeDeactivates:true,delayInitialFocus:true},b);var h={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:false,paused:false,delayInitialFocusTimer:void 0};var y;
/**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */var m=function getOption(e,t,a){return e&&void 0!==e[t]?e[t]:p[a||t]};
/**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */var g=function findContainerIndex(e){return h.containerGroups.findIndex((function(t){var a=t.container,n=t.tabbableNodes;return a.contains(e)||n.find((function(t){return t===e}))}))};
/**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @returns {undefined | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `false` if the option
   *  resolved to `false` (node explicitly not given); otherwise, the resolved
   *  DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node.
   */var O=function getNodeForOption(e){var t=p[e];if("function"===typeof t){for(var a=arguments.length,n=new Array(a>1?a-1:0),r=1;r<a;r++)n[r-1]=arguments[r];t=t.apply(void 0,n)}true===t&&(t=void 0);if(!t){if(void 0===t||false===t)return t;throw new Error("`".concat(e,"` was specified but was not a node, or did not return a node"))}var o=t;if("string"===typeof t){o=d.querySelector(t);if(!o)throw new Error("`".concat(e,"` as selector refers to no known node"))}return o};var F=function getInitialFocusNode(){var e=O("initialFocus");if(false===e)return false;if(void 0===e)if(g(d.activeElement)>=0)e=d.activeElement;else{var t=h.tabbableGroups[0];var a=t&&t.firstTabbableNode;e=a||O("fallbackFocus")}if(!e)throw new Error("Your focus-trap needs to have at least one focusable element");return e};var w=function updateTabbableNodes(){h.containerGroups=h.containers.map((function(n){var r=e(n,p.tabbableOptions);var o=t(n,p.tabbableOptions);return{container:n,tabbableNodes:r,focusableNodes:o,firstTabbableNode:r.length>0?r[0]:null,lastTabbableNode:r.length>0?r[r.length-1]:null,
/**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
nextTabbableNode:function nextTabbableNode(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];var n=o.findIndex((function(t){return t===e}));if(!(n<0))return t?o.slice(n+1).find((function(e){return a(e,p.tabbableOptions)})):o.slice(0,n).reverse().find((function(e){return a(e,p.tabbableOptions)}))}}}));h.tabbableGroups=h.containerGroups.filter((function(e){return e.tabbableNodes.length>0}));if(h.tabbableGroups.length<=0&&!O("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times")};var T=function tryFocus(e){if(false!==e&&e!==d.activeElement)if(e&&e.focus){e.focus({preventScroll:!!p.preventScroll});h.mostRecentlyFocusedNode=e;o(e)&&e.select()}else tryFocus(F())};var k=function getReturnFocusNode(e){var t=O("setReturnFocus",e);return t||false!==t&&e};var E=function checkPointerDown(e){var t=v(e);g(t)>=0||(l(p.clickOutsideDeactivates,e)?y.deactivate({returnFocus:p.returnFocusOnDeactivate&&!n(t,p.tabbableOptions)}):l(p.allowOutsideClick,e)||e.preventDefault())};var N=function checkFocusIn(e){var t=v(e);var a=g(t)>=0;if(a||t instanceof Document)a&&(h.mostRecentlyFocusedNode=t);else{e.stopImmediatePropagation();T(h.mostRecentlyFocusedNode||F())}};var D=function checkTab(e){var t=v(e);w();var r=null;if(h.tabbableGroups.length>0){var o=g(t);var i=o>=0?h.containerGroups[o]:void 0;if(o<0)r=e.shiftKey?h.tabbableGroups[h.tabbableGroups.length-1].lastTabbableNode:h.tabbableGroups[0].firstTabbableNode;else if(e.shiftKey){var u=s(h.tabbableGroups,(function(e){var a=e.firstTabbableNode;return t===a}));u<0&&(i.container===t||n(t,p.tabbableOptions)&&!a(t,p.tabbableOptions)&&!i.nextTabbableNode(t,false))&&(u=o);if(u>=0){var c=0===u?h.tabbableGroups.length-1:u-1;var l=h.tabbableGroups[c];r=l.lastTabbableNode}}else{var f=s(h.tabbableGroups,(function(e){var a=e.lastTabbableNode;return t===a}));f<0&&(i.container===t||n(t,p.tabbableOptions)&&!a(t,p.tabbableOptions)&&!i.nextTabbableNode(t))&&(f=o);if(f>=0){var b=f===h.tabbableGroups.length-1?0:f+1;var d=h.tabbableGroups[b];r=d.firstTabbableNode}}}else r=O("fallbackFocus");if(r){e.preventDefault();T(r)}};var P=function checkKey(e){if(i(e)&&false!==l(p.escapeDeactivates,e)){e.preventDefault();y.deactivate()}else u(e)&&D(e)};var G=function checkClick(e){var t=v(e);if(!(g(t)>=0)&&!l(p.clickOutsideDeactivates,e)&&!l(p.allowOutsideClick,e)){e.preventDefault();e.stopImmediatePropagation()}};var j=function addListeners(){if(h.active){r.activateTrap(y);h.delayInitialFocusTimer=p.delayInitialFocus?c((function(){T(F())})):T(F());d.addEventListener("focusin",N,true);d.addEventListener("mousedown",E,{capture:true,passive:false});d.addEventListener("touchstart",E,{capture:true,passive:false});d.addEventListener("click",G,{capture:true,passive:false});d.addEventListener("keydown",P,{capture:true,passive:false});return y}};var I=function removeListeners(){if(h.active){d.removeEventListener("focusin",N,true);d.removeEventListener("mousedown",E,true);d.removeEventListener("touchstart",E,true);d.removeEventListener("click",G,true);d.removeEventListener("keydown",P,true);return y}};y={get active(){return h.active},get paused(){return h.paused},activate:function activate(e){if(h.active)return this;var t=m(e,"onActivate");var a=m(e,"onPostActivate");var n=m(e,"checkCanFocusTrap");n||w();h.active=true;h.paused=false;h.nodeFocusedBeforeActivation=d.activeElement;t&&t();var r=function finishActivation(){n&&w();j();a&&a()};if(n){n(h.containers.concat()).then(r,r);return this}r();return this},deactivate:function deactivate(e){if(!h.active)return this;var t=_objectSpread2({onDeactivate:p.onDeactivate,onPostDeactivate:p.onPostDeactivate,checkCanReturnFocus:p.checkCanReturnFocus},e);clearTimeout(h.delayInitialFocusTimer);h.delayInitialFocusTimer=void 0;I();h.active=false;h.paused=false;r.deactivateTrap(y);var a=m(t,"onDeactivate");var n=m(t,"onPostDeactivate");var o=m(t,"checkCanReturnFocus");var i=m(t,"returnFocus","returnFocusOnDeactivate");a&&a();var u=function finishDeactivation(){c((function(){i&&T(k(h.nodeFocusedBeforeActivation));n&&n()}))};if(i&&o){o(k(h.nodeFocusedBeforeActivation)).then(u,u);return this}u();return this},pause:function pause(){if(h.paused||!h.active)return this;h.paused=true;I();return this},unpause:function unpause(){if(!h.paused||!h.active)return this;h.paused=false;w();j();return this},updateContainerElements:function updateContainerElements(e){var t=[].concat(e).filter(Boolean);h.containers=t.map((function(e){return"string"===typeof e?d.querySelector(e):e}));h.active&&w();return this}};y.updateContainerElements(f);return y};export{f as createFocusTrap};

